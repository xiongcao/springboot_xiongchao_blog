/*
 Navicat Premium Data Transfer

 Source Server         : 127.0.0.1
 Source Server Type    : MySQL
 Source Server Version : 80017
 Source Host           : localhost:3306
 Source Schema         : xiongchao_blog

 Target Server Type    : MySQL
 Target Server Version : 80017
 File Encoding         : 65001

 Date: 27/08/2019 18:39:35
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for app_config
-- ----------------------------
DROP TABLE IF EXISTS `app_config`;
CREATE TABLE `app_config` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `admin_id` int(11) NOT NULL,
  `app_id` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `msg_data_format` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT 'JSON',
  `remark` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  `secret` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_4tx7s9tear1to7lq9g9n3joq3` (`admin_id`),
  UNIQUE KEY `UK_boipwfawtfve9o09lnb5le29a` (`app_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for assets_group
-- ----------------------------
DROP TABLE IF EXISTS `assets_group`;
CREATE TABLE `assets_group` (
  `id` int(11) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '组名',
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `status` int(11) DEFAULT '1' COMMENT '1：正常 0：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `rank` int(11) DEFAULT '0' COMMENT '排序序号',
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  `status` int(255) DEFAULT '1' COMMENT '1：正常 0：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
BEGIN;
INSERT INTO `category` VALUES (1, '前端', 2, '2019-07-19 14:17:25', '2019-07-19 15:37:09', 1, NULL, 1);
INSERT INTO `category` VALUES (2, 'Java', 1, '2019-08-01 15:56:21', '2019-08-01 15:56:21', 1, NULL, 1);
INSERT INTO `category` VALUES (3, 'C#', 1, '2019-07-19 17:34:31', '2019-08-01 15:55:13', 2, 'category_cover/i6nDqTCd.gif', 1);
INSERT INTO `category` VALUES (4, 'C++', 2, '2019-07-19 17:34:34', '2019-08-01 17:57:59', 2, 'category_cover/5NJkt41L.gif', 1);
INSERT INTO `category` VALUES (5, 'js', 2, '2019-07-23 17:34:38', '2019-08-06 13:47:04', 2, 'category_cover/KbtnSO5Z.gif', 1);
INSERT INTO `category` VALUES (7, '后端', 2, '2019-07-19 14:17:25', '2019-07-19 15:37:09', 1, '', 1);
INSERT INTO `category` VALUES (9, 'javascript', 0, '2019-08-01 11:38:32', '2019-08-01 18:11:12', 2, 'category_cover/HV1Y7cuh.gif', 1);
INSERT INTO `category` VALUES (10, '运营', 2, '2019-08-01 15:56:21', '2019-08-01 15:56:21', 1, '', 1);
INSERT INTO `category` VALUES (12, '运营', 2, '2019-08-01 16:09:19', '2019-08-01 16:33:38', 2, 'category_cover/ewSQ8ckQ.jpg', 1);
INSERT INTO `category` VALUES (13, 'Java', 1, '2019-08-01 16:09:19', '2019-08-01 16:33:58', 2, 'category_cover/HbxD8KJ5.gif', 1);
COMMIT;

-- ----------------------------
-- Table structure for collect
-- ----------------------------
DROP TABLE IF EXISTS `collect`;
CREATE TABLE `collect` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  `essay_id` int(11) NOT NULL,
  `status` int(11) DEFAULT '1' COMMENT '1：正常 0：隐藏 -1：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of collect
-- ----------------------------
BEGIN;
INSERT INTO `collect` VALUES (1, '2019-07-29 14:53:12', '2019-07-29 14:53:14', 1, 1, 1);
INSERT INTO `collect` VALUES (2, '2019-07-29 14:53:03', '2019-08-26 16:52:49', 2, 14, 0);
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `pid` int(11) DEFAULT NULL COMMENT '父级评论ID',
  `content` varchar(10000) NOT NULL,
  `essay_id` int(11) NOT NULL COMMENT '文章id',
  `to_user_id` int(11) NOT NULL COMMENT '被评论者',
  `user_id` int(11) NOT NULL COMMENT '创建者',
  `status` int(11) DEFAULT '1' COMMENT '1：正常 0：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES (1, '2019-07-26 15:32:47', '2019-07-26 18:49:10', 0, '小熊对小熊对直接评论', 23, 2, 2, 1);
INSERT INTO `comment` VALUES (2, '2019-07-26 15:32:47', '2019-07-26 18:49:10', 0, '伙伴A对小熊对评论', 23, 2, 3, 1);
INSERT INTO `comment` VALUES (3, '2019-07-26 15:32:47', '2019-07-26 18:49:10', 2, '小熊回复伙伴A的评论', 23, 3, 2, 1);
INSERT INTO `comment` VALUES (4, '2019-08-16 15:56:32', '2019-08-16 15:56:36', 3, '伙伴A回复小熊的评论', 23, 2, 3, 1);
INSERT INTO `comment` VALUES (5, '2019-08-16 15:56:32', '2019-08-16 15:56:36', 0, '伙伴B对小熊的直接评论', 23, 2, 4, 1);
COMMIT;

-- ----------------------------
-- Table structure for essay
-- ----------------------------
DROP TABLE IF EXISTS `essay`;
CREATE TABLE `essay` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  `type` int(11) DEFAULT '0' COMMENT '标签 0：原创 1：转发',
  `des` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` varchar(20000) DEFAULT NULL,
  `star` int(11) DEFAULT '0' COMMENT '点赞数',
  `browse_number` int(11) DEFAULT NULL COMMENT '浏览次数',
  `rank` int(11) DEFAULT '0',
  `user_id` int(11) NOT NULL,
  `status` int(11) DEFAULT '1' COMMENT '1：公开  2：私密 3：草稿 0：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of essay
-- ----------------------------
BEGIN;
INSERT INTO `essay` VALUES (9, '测试title11', '2019-08-01 10:34:09', '2019-07-26 14:58:48', NULL, 0, '1', '<p>hahahah</p>\n', 0, 1, 0, 2, 3);
INSERT INTO `essay` VALUES (10, 'test', '2019-08-02 10:34:07', '2019-07-25 15:37:46', NULL, NULL, '2', '<p>jjjjjhahahah</p>\n', 1, NULL, 0, 3, 1);
INSERT INTO `essay` VALUES (12, '测试title11', '2019-08-03 10:34:04', '2019-07-31 19:15:23', 'essay_cover/RAluLXwS.gif', 1, '4', 'content: ## 前言\n\n![JavaScript 数据结构与算法之美](https://upload-images.jianshu.io/upload_images/12890819-9f08a1abed2d7caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![全栈修炼](https://upload-images.jianshu.io/upload_images/12890819-f0ff03ca21df2481.gif?imageMogr2/auto-orient/strip)\n\n\n## 前言\n\n> 算法为王。\n\n> 想学好前端，先练好内功，内功不行，就算招式练的再花哨，终究成不了高手；只有内功深厚者，前端之路才会走得更远。\n\n强烈推荐 GitHub 上值得前端学习的数据结构与算法项目，包含 gif 图的演示过程与视频讲解。\n\n##  GitHub 项目\n\n### 数据结构与算法\n\n关于数据结构与算法的 GitHub 项目，star 数由高到低排序。\n\n- [javascript-algorithms（51.3k）](https://github.com/trekhleb/javascript-algorithms)\n该仓库包含了多种基于 JavaScript 的算法与数据结构，提供进一步阅读的解释和链接。\n每种算法和数据结构都有自己的 README，包含相关说明和链接，以便进一步阅读 (还有 YouTube 视频) 。\n- [Algorithm_Interview_Notes-Chinese（24.6k）](https://github.com/imhuay/Algorithm_Interview_Notes-Chinese)\n2018/2019/校招/春招/秋招/算法/机器学习(Machine Learning)/深度学习(Deep Learning)/自然语言处理(NLP)/C/C++/Python/面试笔记\n- [algorithm-visualizer（23k）](https://github.com/algorithm-visualizer/algorithm-visualizer)\n算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。\n- [swift-algorithm-club（20.8k）](https://github.com/raywenderlich/swift-algorithm-club)\n算法和数据结构迅速，有解释 ！\n- [algorithms（15.4k）](https://github.com/keon/algorithms)\nPython中数据结构和算法的最小示例。\n- [algo（8.3k）](https://github.com/wangzheng0822/algo)\n数据结构和算法必知必会的50个代码实现。\n- [awesome-algorithms（6.4k）](https://github.com/tayllan/awesome-algorithms)\n一份很棒的学习和/或练习算法的地方的整理清单。\n- [algorithms](https://github.com/jeffgerickson/algorithms)\n对Jeff的算法书、笔记等进行错误跟踪\n- [javascript-algorithms（5.4k）](https://github.com/mgechev/javascript-algorithms)\n此存储库包含不同著名计算机科学算法的 javascript 实现。\n- [Learn-Algorithms（3.8k）](https://github.com/nonstriater/Learn-Algorithms)\n算法学习笔记。\n- [AlgoXY（3.8k）](https://github.com/liuxinyu95/AlgoXY)\n基本算法和数据结构手册。\n- [JavaScript 更多 ... ](https://github.com/search?l=JavaScript&o=desc&q=algo&s=stars&type=Repositories)\n- [其他语言，更多 ... ](https://github.com/search?o=desc&p=1&q=algo&s=stars&type=Repositories)\n\n### LeetCode \n\n关于 LeetCode 的 GitHub 项目，star 数由高到低排序。\n\n- [LeetCodeAnimation（36k）](https://github.com/MisterBooo/LeetCodeAnimation)\n用动画的形式呈现解LeetCode题目的思路。\n- [leetcode（13.6k）](https://github.com/azl397985856/leetcode)\nleetcode 题解，记录自己的leetcode解题之路。\n- [leetcode（11.2k）](https://github.com/haoel/leetcode)\nleetcode 问题解决方案。\n- [leetcode（7.7k）](https://github.com/soulmachine/leetcode)\nLeetCode题解，151道题完整版。\n- [awesome-java-leetcode（6.2k）](https://github.com/Blankj/awesome-java-leetcode)\nLeetCode算法与Java解决方案（更新）。\n- [vscode-leetcode（4.1k）](https://github.com/jdneo/vscode-leetcode/blob/master/docs/README_zh-CN.md)\n在 VS Code 中练习 LeetCode。\n- [LintCode（3.4k）](https://github.com/awangdev/LintCode)\nLintCode/LeetCode 的 Java 解决方法。\n- [algorithm-exercise（2.6k）](https://github.com/billryan/algorithm-exercise)\n数据结构与算法/leetcode/lintcode题解/ \n- [更多 ... ](https://github.com/search?o=desc&p=1&q=leetcode&s=stars&type=Repositories)\n\n\n## 算法可视化工具\n\n- 算法可视化工具 [algorithm-visualizer](https://github.com/algorithm-visualizer/algorithm-visualizer) \n 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。\n\n效果如下图。\n\n![算法可视化工具](https://upload-images.jianshu.io/upload_images/12890819-0af779615ee7fc27.gif?imageMogr2/auto-orient/strip)\n\n\n旨在通过交互式可视化的执行来揭示算法背后的机制。\n\n\n- [illustrated-algorithms](https://github.com/skidding/illustrated-algorithms)\n\n变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。\n\n![binary-search.gif](https://upload-images.jianshu.io/upload_images/12890819-22bd05d89a89af8c.gif?imageMogr2/auto-orient/strip)\n\n\n## JavaScript 数据结构与算法之美\n\n**JavaScript 数据结构与算法之美**系列是笔者写的， 用的语言是 **JavaScript** ，旨在入门数据结构与算法和方便以后复习。\n\n- [1. JavaScript 数据结构与算法之美 - 时间和空间复杂度](https://github.com/biaochenxuying/blog/issues/29)\n- [2. JavaScript 数据结构与算法之美 - 线性表（数组、队列、栈、链表）](https://github.com/biaochenxuying/blog/issues/34)\n- [3. JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？](https://github.com/biaochenxuying/blog/issues/30)\n- [4. JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝](https://github.com/biaochenxuying/blog/issues/35)\n- [5. JavaScript 数据结构与算法之美 - 递归](https://github.com/biaochenxuying/blog/issues/36)\n- [6. JavaScript 数据结构与算法之美 - 非线性表（树、堆）](https://github.com/biaochenxuying/blog/issues/37)\n- [7. JavaScript 数据结构与算法之美 - 冒泡排序、选择排序、插入排序](https://github.com/biaochenxuying/blog/issues/39)\n- [8. JavaScript 数据结构与算法之美 - 归并排序、快速排序、希尔排序、堆排序](https://github.com/biaochenxuying/blog/issues/40) | 精彩待续\n- [9. JavaScript 数据结构与算法之美 - 计数排序、桶排序、基数排序](https://github.com/biaochenxuying/blog/issues/41) | 精彩待续\n- [10. JavaScript 数据结构与算法之美 - 十大经典排序汇总](https://github.com/biaochenxuying/blog/issues/42) | 精彩待续\n- [11. JavaScript 数据结构与算法之美 - 强烈推荐 GitHub 上值得前端学习的数据结构与算法项目](https://github.com/biaochenxuying/blog/issues/43)\n\n## 最后\n\n觉得有用 ？喜欢就点个赞吧。\n\n\n![全栈修炼](https://upload-images.jianshu.io/upload_images/12890819-548ff9a6a6547b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)', 1, 2, 1, 2, 2);
INSERT INTO `essay` VALUES (13, 'test', '2018-08-04 10:34:02', '2019-08-20 16:31:38', 'essay_cover/RAluLXwS.gif', 0, 'HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` jsonp\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 3, 4, 0, 2, 1);
INSERT INTO `essay` VALUES (14, 'Ajax跨域的几种解决方案', '2018-08-05 14:52:25', '2019-08-26 15:54:08', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 2, 6, 3, 2, 1);
INSERT INTO `essay` VALUES (15, 'Ajax跨域的几种解决方案', '2018-08-06 14:52:25', '2019-08-23 18:29:01', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 89, 3, 2, 1);
INSERT INTO `essay` VALUES (16, 'Ajax跨域的几种解决方案', '2019-08-07 14:52:25', '2019-08-08 17:09:01', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 4, 3, 2, 1);
INSERT INTO `essay` VALUES (17, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:00', '2019-08-14 13:58:10', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 7, 3, 2, 2);
INSERT INTO `essay` VALUES (18, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:01', '2019-08-08 17:08:43', '', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 4, 3, 2, 1);
INSERT INTO `essay` VALUES (19, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:02', '2019-08-08 17:08:32', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 4, 3, 2, 1);
INSERT INTO `essay` VALUES (20, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:03', '2019-08-08 17:08:21', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 4, 3, 2, 1);
INSERT INTO `essay` VALUES (21, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:04', '2019-08-08 17:08:08', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 4, 3, 2, 2);
INSERT INTO `essay` VALUES (22, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:05', '2019-08-14 10:54:59', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 40, 3, 2, 1);
INSERT INTO `essay` VALUES (23, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:06', '2019-08-19 17:31:03', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 9, 3, 2, 1);
INSERT INTO `essay` VALUES (24, 'Ajax跨域的几种解决方案', '2019-08-08 08:00:07', '2019-08-23 18:25:13', 'essay_cover/RAluLXwS.gif', 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 10, 3, 2, 1);
INSERT INTO `essay` VALUES (25, 'Ajax跨域的几种解决方案hhh', '2019-08-08 08:00:08', '2019-08-23 16:38:38', NULL, 0, '跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。sdfdssfdsf', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n## 何为跨域请求\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n\n## 几种常见跨域请求\n\n|  请求地址  | 服务器地址 | 结果 |\n| --------   | -----  | :----:  |\n| http://www.123.com | http://www.abc.com | (主域名不同，跨域)\n| http://123.xiongchao.com | http://abc.xiongchao.com | (子域名不同，跨域)\n| http://www.xiongchao.com:8080 | http://www.xiongchao.com:8081 | (端口不同，跨域)\n| http://www.xiongchao.com | https://www.xiongchao.com | (协议不同，跨域)\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n<!-- more --> \n## 跨域情形\n\n\n请求代码：\n``` js\nvar requestApi = \"http://localhost:8080/springmvc_hibernate_maven/\";\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n});\n```\n\n服务器端java代码\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n浏览器中访问（将html部署到nginx）结果:\n![](http://www.xiongchao.win/blogImage/201808141515_419.png)\n![](http://www.xiongchao.win/blogImage/201808141516_535.png)\n\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n\n\n## 常见几种解决方案\n\n### jsonp方式处理（基本被淘汰了）\n先看看json和jsonp数据格式的区别：\n#### json格式\n``` json\n{\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n}\n```\n\n#### jsonp格式\n``` json\ncallback({\n  \"id\":\"1\",\n  \"name\":\"java\",\n  \"password\":\"123456\",\n  \"loginDate\":\"2018-08-14\"\n})\n```\njsonp比json外面有多了一层，callback()。\n\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo?callback=\",\n    dataType:\'jsonp\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n\n服务器端处理：\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletRequest request){\n                String callback = request.getParameter(\"callback\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return callback+\"(\" + JSONObject.toJSONString(user) + \")\";\n	}\n}\n```\n\n我们看一下后台获取的callback的值\n![](http://www.xiongchao.win/blogImage/201808141602_241.png)\n\n修改请求代码再看一下后台获取的callback的值\n``` js\n$.ajax({\n    type:\'get\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'jsonp\',\n    jsonpCallback:\'testCallback\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err){\n        console.log(err);\n    }\n})\n```\n正是我们自定义的callback的值\n![](http://www.xiongchao.win/blogImage/201808141605_213.png)\n\n最后查看请求结果，控制台成功打印获取获取的数据\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n\n#### <font color=\"red\">需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</font>\n#### <font color=\"red\">另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。</font>\n\n\n### java服务器端添加允许跨域请求的响应头\n\najax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.GET)\n	public String getUserInfo(HttpServletResponse httpServletResponse){\n                httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		System.out.println(JSON.toJSONString(user));\n		return JSON.toJSONString(user);\n	}\n}\n```\n\n结果：\n![](http://www.xiongchao.win/blogImage/201808141525_79.png)\n成功请求！\n\n\n### 比jsonp更强大的CORS方式解决跨域\n\n基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n\n这里介绍的是java后端应该如何配置以解决问题\n\n第一步：\n1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下\n2.mavne项目：添加如下依赖到pom.xml中\n``` xml\n<dependency>\n  <groupId>com.thetransactioncompany</groupId>\n  <artifactId>cors-filter</artifactId>\n  <version>2.6</version>\n</dependency>\n```\n\n第二步:添加CORS配置到项目的Web.xml中(/WEB-INF/web.xml)\n```\n<!-- 跨域配置 -->\n<filter>\n  <!-- The CORS filter with parameters -->\n  <filter-name>CORS</filter-name>\n  <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class>\n  <!-- Note: All parameters are options, if omitted the CORS Filter will \n    fall back to the respective default values. -->\n  <init-param>\n    <param-name>cors.allowGenericHttpRequests</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowOrigin</param-name>\n    <param-value>*</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.allowSubdomains</param-name>\n    <param-value>false</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedMethods</param-name>\n    <param-value>GET, HEAD, POST,PUT,DELETE OPTIONS</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportedHeaders</param-name>\n    <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.exposedHeaders</param-name>\n    <!--这里可以添加一些自己的暴露Headers -->\n    <param-value>X-Test-1, X-Test-2</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.supportsCredentials</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>cors.maxAge</param-name>\n    <param-value>3600</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <!-- CORS Filter mapping -->\n  <filter-name>CORS</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n\n现在我们再来正常请求和处理请求试一下\n``` js\n$.ajax({\n    type:\'delete\',\n    url:requestApi + \"test/userInfo\",\n    dataType:\'json\',\n    success:function(data){\n        console.log(data);\n    },\n    error:function(err,textStatus){\n        console.log(\"err\",err);\n    }\n})\n```\n\n``` java\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n	@ResponseBody\n	@RequestMapping(value = \"/userInfo\",method = RequestMethod.DELETE)\n	public String getUserInfo(HttpServletRequest request,HttpServletResponse response){\n		User user = new User();\n		user.setId(1);\n		user.setName(\"java\");\n		user.setPassword(\"123456\");\n		user.setLoginDate(\"2018-08-14\");\n		return JSONObject.toJSONString(user); \n	}\n}\n```\n\n请求结果：可以看到有OPTIONS请求了\n![](http://www.xiongchao.win/blogImage/201808141716_132.png)\n![](http://www.xiongchao.win/blogImage/201808141716_238.png)\n![](http://www.xiongchao.win/blogImage/201808141607_11.png)\n', 4, 5, 3, 2, 1);
COMMIT;

-- ----------------------------
-- Table structure for essay_category_mapping
-- ----------------------------
DROP TABLE IF EXISTS `essay_category_mapping`;
CREATE TABLE `essay_category_mapping` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `category_id` int(11) NOT NULL,
  `essay_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=71 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of essay_category_mapping
-- ----------------------------
BEGIN;
INSERT INTO `essay_category_mapping` VALUES (42, '2019-08-06 13:47:23', '2019-08-06 13:47:23', 3, 9);
INSERT INTO `essay_category_mapping` VALUES (23, '2019-07-26 14:58:48', '2019-07-26 14:58:48', 4, 10);
INSERT INTO `essay_category_mapping` VALUES (34, '2019-07-31 19:15:23', '2019-07-31 19:15:23', 5, 12);
INSERT INTO `essay_category_mapping` VALUES (37, '2019-08-06 11:31:38', '2019-08-06 11:31:38', 3, 13);
INSERT INTO `essay_category_mapping` VALUES (70, '2019-08-23 16:38:38', '2019-08-23 16:38:38', 4, 25);
INSERT INTO `essay_category_mapping` VALUES (41, '2019-08-06 13:46:44', '2019-08-06 13:46:44', 12, 15);
INSERT INTO `essay_category_mapping` VALUES (47, '2019-08-08 17:07:34', '2019-08-08 17:07:34', 4, 24);
INSERT INTO `essay_category_mapping` VALUES (63, '2019-08-13 14:50:05', '2019-08-13 14:50:05', 5, 23);
INSERT INTO `essay_category_mapping` VALUES (49, '2019-08-08 17:07:56', '2019-08-08 17:07:56', 12, 22);
INSERT INTO `essay_category_mapping` VALUES (50, '2019-08-08 17:08:08', '2019-08-08 17:08:08', 3, 21);
INSERT INTO `essay_category_mapping` VALUES (51, '2019-08-08 17:08:21', '2019-08-08 17:08:21', 13, 20);
INSERT INTO `essay_category_mapping` VALUES (52, '2019-08-08 17:08:32', '2019-08-08 17:08:32', 9, 19);
INSERT INTO `essay_category_mapping` VALUES (53, '2019-08-08 17:08:43', '2019-08-08 17:08:43', 5, 18);
INSERT INTO `essay_category_mapping` VALUES (54, '2019-08-08 17:08:51', '2019-08-08 17:08:51', 12, 17);
INSERT INTO `essay_category_mapping` VALUES (55, '2019-08-08 17:09:01', '2019-08-08 17:09:01', 5, 16);
INSERT INTO `essay_category_mapping` VALUES (56, '2019-08-08 17:09:08', '2019-08-08 17:09:08', 12, 14);
COMMIT;

-- ----------------------------
-- Table structure for essay_tag_mapping
-- ----------------------------
DROP TABLE IF EXISTS `essay_tag_mapping`;
CREATE TABLE `essay_tag_mapping` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `essay_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of essay_tag_mapping
-- ----------------------------
BEGIN;
INSERT INTO `essay_tag_mapping` VALUES (41, '2019-08-06 11:31:38', '2019-08-06 11:31:38', 13, 9);
INSERT INTO `essay_tag_mapping` VALUES (46, '2019-08-06 13:47:23', '2019-08-06 13:47:23', 9, 4);
INSERT INTO `essay_tag_mapping` VALUES (47, '2019-08-06 13:47:23', '2019-08-06 13:47:23', 9, 8);
INSERT INTO `essay_tag_mapping` VALUES (71, '2019-08-08 17:09:08', '2019-08-08 17:09:08', 14, 8);
INSERT INTO `essay_tag_mapping` VALUES (39, '2019-07-31 19:15:23', '2019-07-31 19:15:23', 12, 2);
INSERT INTO `essay_tag_mapping` VALUES (45, '2019-08-06 13:46:44', '2019-08-06 13:46:44', 15, 8);
INSERT INTO `essay_tag_mapping` VALUES (99, '2019-08-23 16:38:38', '2019-08-23 16:38:38', 25, 4);
INSERT INTO `essay_tag_mapping` VALUES (98, '2019-08-23 16:38:38', '2019-08-23 16:38:38', 25, 2);
INSERT INTO `essay_tag_mapping` VALUES (53, '2019-08-08 17:07:34', '2019-08-08 17:07:34', 24, 2);
INSERT INTO `essay_tag_mapping` VALUES (54, '2019-08-08 17:07:34', '2019-08-08 17:07:34', 24, 9);
INSERT INTO `essay_tag_mapping` VALUES (85, '2019-08-13 14:50:05', '2019-08-13 14:50:05', 23, 8);
INSERT INTO `essay_tag_mapping` VALUES (84, '2019-08-13 14:50:04', '2019-08-13 14:50:04', 23, 4);
INSERT INTO `essay_tag_mapping` VALUES (57, '2019-08-08 17:07:56', '2019-08-08 17:07:56', 22, 4);
INSERT INTO `essay_tag_mapping` VALUES (58, '2019-08-08 17:07:56', '2019-08-08 17:07:56', 22, 9);
INSERT INTO `essay_tag_mapping` VALUES (59, '2019-08-08 17:08:08', '2019-08-08 17:08:08', 21, 4);
INSERT INTO `essay_tag_mapping` VALUES (60, '2019-08-08 17:08:08', '2019-08-08 17:08:08', 21, 8);
INSERT INTO `essay_tag_mapping` VALUES (61, '2019-08-08 17:08:08', '2019-08-08 17:08:08', 21, 9);
INSERT INTO `essay_tag_mapping` VALUES (62, '2019-08-08 17:08:21', '2019-08-08 17:08:21', 20, 2);
INSERT INTO `essay_tag_mapping` VALUES (63, '2019-08-08 17:08:21', '2019-08-08 17:08:21', 20, 4);
INSERT INTO `essay_tag_mapping` VALUES (64, '2019-08-08 17:08:21', '2019-08-08 17:08:21', 20, 8);
INSERT INTO `essay_tag_mapping` VALUES (65, '2019-08-08 17:08:32', '2019-08-08 17:08:32', 19, 4);
INSERT INTO `essay_tag_mapping` VALUES (66, '2019-08-08 17:08:32', '2019-08-08 17:08:32', 19, 8);
INSERT INTO `essay_tag_mapping` VALUES (67, '2019-08-08 17:08:32', '2019-08-08 17:08:32', 19, 9);
INSERT INTO `essay_tag_mapping` VALUES (68, '2019-08-08 17:08:43', '2019-08-08 17:08:43', 18, 2);
INSERT INTO `essay_tag_mapping` VALUES (69, '2019-08-08 17:08:51', '2019-08-08 17:08:51', 17, 8);
INSERT INTO `essay_tag_mapping` VALUES (70, '2019-08-08 17:09:01', '2019-08-08 17:09:01', 16, 8);
COMMIT;

-- ----------------------------
-- Table structure for follow
-- ----------------------------
DROP TABLE IF EXISTS `follow`;
CREATE TABLE `follow` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `created_date` datetime DEFAULT NULL,
  `follow_user_id` int(11) NOT NULL COMMENT '被关注用户的id(粉丝）',
  `user_id` int(11) NOT NULL COMMENT '关注用户的id',
  `status` int(11) DEFAULT NULL COMMENT '0：删除 1：关注 2：粉丝',
  `mutual_watch` bit(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of follow
-- ----------------------------
BEGIN;
INSERT INTO `follow` VALUES (14, 'watch', 'xiaoding', '小丁aaa', '2019-08-26 16:27:35', '2019-06-06 15:26:10', 4, 2, 0, NULL);
INSERT INTO `follow` VALUES (15, 'watch', 'xiaowang', 'sssaa=', '2019-08-26 16:28:07', '2019-07-29 17:36:44', 3, 2, 0, NULL);
INSERT INTO `follow` VALUES (16, 'watch', 'xiongchao', '小丁', '2019-07-29 17:36:46', '2019-07-29 17:36:49', 2, 3, 1, NULL);
INSERT INTO `follow` VALUES (17, 'fans', 'xiongchao', '小熊', '2019-08-26 16:27:52', '2019-07-29 17:36:54', 2, 3, 0, NULL);
INSERT INTO `follow` VALUES (18, 'fans', 'xiongchao', '小熊', '2019-08-26 16:27:35', '2019-07-29 17:44:49', 2, 4, 0, NULL);
INSERT INTO `follow` VALUES (19, 'fans', 'xiaowang', '小王', '2019-08-26 16:27:52', '2019-07-29 17:44:54', 3, 2, 0, NULL);
COMMIT;

-- ----------------------------
-- Table structure for image_list
-- ----------------------------
DROP TABLE IF EXISTS `image_list`;
CREATE TABLE `image_list` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL COMMENT '文件名',
  `path` varchar(255) DEFAULT NULL COMMENT '短路径',
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `status` int(255) DEFAULT '1' COMMENT '1：正常 0：删除',
  `type` int(11) DEFAULT NULL COMMENT '1：文章 2：评论',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type` int(11) DEFAULT NULL COMMENT '消息类型：1：关注 2：评论 3：回复 4：系统',
  `send_id` int(11) DEFAULT NULL,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `status` int(11) DEFAULT '1' COMMENT '1：正常 0：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of message
-- ----------------------------
BEGIN;
INSERT INTO `message` VALUES (1, 1, 2, '2019-05-28 16:47:23', '2019-05-28 16:47:28', 1);
INSERT INTO `message` VALUES (2, 1, 2, '2019-05-28 16:47:53', '2019-05-28 16:47:55', 1);
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `rank` int(11) DEFAULT '0' COMMENT '排序序号',
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  `status` int(11) DEFAULT '1' COMMENT '1：正常 0：隐藏 -1：删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES (2, 'css', 2, '2019-05-28 16:47:02', '2019-07-26 14:56:00', 2, 1);
INSERT INTO `tag` VALUES (3, 'html', 0, '2019-07-25 17:00:17', '2019-07-25 17:00:19', 3, 1);
INSERT INTO `tag` VALUES (4, 'jquery', 0, '2019-07-26 14:57:09', '2019-08-06 13:46:51', 2, 1);
INSERT INTO `tag` VALUES (5, 'flex', 0, '2019-07-31 15:11:42', '2019-07-31 15:11:42', 1, 1);
INSERT INTO `tag` VALUES (6, 'es6', 0, '2019-07-31 15:12:04', '2019-07-31 15:12:04', 1, 1);
INSERT INTO `tag` VALUES (7, 'js', 0, '2019-07-31 15:12:11', '2019-07-31 15:12:11', 1, 1);
INSERT INTO `tag` VALUES (8, 'es6', 0, '2019-08-01 16:26:35', '2019-08-01 16:26:35', 2, 1);
INSERT INTO `tag` VALUES (9, 'js', 0, '2019-08-01 16:26:35', '2019-08-01 16:26:35', 2, 1);
COMMIT;

-- ----------------------------
-- Table structure for test
-- ----------------------------
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `id` int(11) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `class_id` int(11) DEFAULT NULL,
  `score` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of test
-- ----------------------------
BEGIN;
INSERT INTO `test` VALUES (1, 'zs', 1, 80);
INSERT INTO `test` VALUES (2, 'aa', 1, 100);
INSERT INTO `test` VALUES (3, 'bb', 1, 60);
INSERT INTO `test` VALUES (4, 'cc', 1, 70);
INSERT INTO `test` VALUES (5, 'dd', 2, 90);
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `motto` varchar(255) DEFAULT NULL COMMENT '座右铭',
  `password` varchar(255) NOT NULL,
  `phone_number` varchar(20) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `created_date` datetime DEFAULT NULL,
  `last_modified_date` datetime DEFAULT NULL,
  `locked_date` datetime DEFAULT NULL,
  `password_attempt_count` int(11) DEFAULT '0',
  `introduce` varchar(1000) DEFAULT NULL COMMENT '个人介绍',
  `role` varchar(255) NOT NULL DEFAULT 'ROLE_USER' COMMENT 'super：超管 user：普通用户',
  `birthday` date DEFAULT NULL,
  `gender` int(11) DEFAULT '2' COMMENT '0：男 1：女 2：未知',
  `email` varchar(255) DEFAULT NULL,
  `we_chat_name` varchar(255) DEFAULT NULL,
  `we_chat_openid` varchar(255) DEFAULT NULL,
  `we_chat_unionid` varchar(255) DEFAULT NULL,
  `level` int(11) DEFAULT '1' COMMENT '等级',
  `integral` int(11) DEFAULT '0' COMMENT '积分',
  `coin` int(255) DEFAULT '0' COMMENT '熊币',
  `status` int(11) DEFAULT '1' COMMENT '0：删除, 1:正常, 2:密码尝试锁定, 3:上级领导锁定',
  `province` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '区域',
  `city` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '省份',
  `area` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '城市',
  `industry` varchar(255) DEFAULT NULL COMMENT '行业',
  `positiom` varchar(255) DEFAULT NULL COMMENT '职位',
  `we_chat_open_id` varchar(225) DEFAULT NULL,
  `position` varchar(225) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`) USING BTREE,
  UNIQUE KEY `phone_number` (`phone_number`)
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, 'super', '超管', NULL, '$2a$10$xjg/c3rKG2n3OOhOnjuW3eS5FPZmO.Sk/BvuxhCmKn1QWn9ai4DzO', '15727055403', NULL, '2019-05-28 16:44:21', '2019-06-28 15:35:46', NULL, 0, NULL, 'ROLE_SUPER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (2, 'xiongchao', '安妮的小熊', '海乃百川，有容乃大', '$2a$10$FsXgL9Mkgl.uDAInwm7pFe7VjgvEe2R7eFLZILpF9Im7xtiIe23aK', '15727055402', 'avatar/3hImXO4r.gif', '2019-05-28 16:44:21', '2019-08-27 15:40:20', NULL, 0, '心有多大，梦想就有多大。', 'ROLE_USER', '1995-08-25', 0, '1359209000@qq.com', '', '', '', 1, 0, 0, 1, '上海市', '市辖区', '闵行区', '互联网', NULL, NULL, 'web全栈工程师');
INSERT INTO `user` VALUES (3, 'xiaowang', '小王', NULL, '$2a$10$FsXgL9Mkgl.uDAInwm7pFe7VjgvEe2R7eFLZILpF9Im7xtiIe23aK', '15727055401', NULL, '2019-06-06 14:39:59', NULL, NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (4, 'xiaoding', '小丁', NULL, '$2a$10$xjg/c3rKG2n3OOhOnjuW3eS5FPZmO.Sk/BvuxhCmKn1QWn9ai4DzO', '15727055405', NULL, '2019-06-06 16:04:09', NULL, NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (10, 'xiaoxiong', NULL, NULL, '$2a$10$DQEP2BYYvoQCmUGbfobfi.RdiGfiBJ2f.XNl9mTOXBY5Thx31Vr9m', '15727055406', NULL, '2019-07-30 19:03:11', '2019-07-30 19:03:11', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (11, 'xiaoming', NULL, NULL, '$2a$10$rg2M4y6OnL309PZiIT.Qg.L2O6YoAqBUmBDPKwb2sELo0JIiG/GVe', '15727055407', NULL, '2019-07-30 19:06:15', '2019-07-30 19:06:15', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (12, 'xiaohouzi', NULL, NULL, '$2a$10$64ZJqZWPIXVbFL4RsOc.Ne7DCvSe5cLqC1lMcmyjXs0tUpkpXChKy', '15727055408', NULL, '2019-07-30 19:08:13', '2019-07-30 19:08:13', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (13, 'dingding', NULL, NULL, '$2a$10$bZcj1BNcRie4R.1v.iIISeF5QX6idgdAVgRHeGyO0Wj1OPwTqrpLm', '15727055409', NULL, '2019-07-30 19:09:20', '2019-07-30 19:09:20', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (14, 'dingding2', NULL, NULL, '$2a$10$LvOvCJPLiXNevi7h2dCPxeHR4buJt/HTmw.Ks8coXZSNMcI15f5jO', '15727055419', NULL, '2019-07-30 19:09:53', '2019-07-30 19:09:53', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (15, 'dingding3', NULL, NULL, '$2a$10$vVXeTbn0rj34P/Nr1RxJJ.CRgSJRGcjqYwUT1nbEX0m2fRLE3ckEu', '15727055410', NULL, '2019-07-31 09:30:52', '2019-07-31 09:30:52', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (18, 'dingding4', NULL, NULL, '$2a$10$FRECDBBL71bqi2UmkarWs.zXuCtlYNH2J4CS0Z2HZ6QrZT4AcLhLm', '15727055411', NULL, '2019-07-31 09:33:52', '2019-07-31 09:33:52', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (19, 'dingding5', NULL, NULL, '$2a$10$YIS6l5BbQlxllGS0cYBPEuEAEWjHgTiK0JXkigCbX8tNttR7FGnde', '15727055412', NULL, '2019-07-31 09:34:55', '2019-07-31 09:34:55', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (20, 'dingding6', NULL, NULL, '$2a$10$ukfcOtYCK1gt2gDlz1TAZ.SI4j/btnotTSWUoS6lMgvJXzD7YnNxG', '15727055413', NULL, '2019-07-31 09:36:25', '2019-07-31 09:36:25', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (21, 'dingding7', NULL, NULL, '$2a$10$7i0Wv0Own46Z1xLaDGKJ5ObPtMEE1UplrSl4L1qGIP07fHkWFTSYC', '15727055414', NULL, '2019-07-31 09:38:32', '2019-07-31 09:38:32', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (22, 'dingding8', NULL, NULL, '$2a$10$fIe6.UtNHe/GaO6j0jo4v.Kw3hxzux3cCfssp.NmpGUXUnAogOnMy', '15727055415', NULL, '2019-07-31 09:44:36', '2019-07-31 09:44:36', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (23, 'dingding9', NULL, NULL, '$2a$10$0KLBKXfWalDPb9GbqCr6XuSigXYE9qomCacNUygeWL2HrwDEEscYC', '15727055417', NULL, '2019-07-31 09:54:49', '2019-07-31 09:54:49', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (24, 'xiaoming1', NULL, NULL, '$2a$10$sifx9KW6KrN7dSvqhsoUPO/FO.wPnDspX1Qpx0DPNcG.Z2GrFNgc6', '15727055420', NULL, '2019-07-31 10:01:14', '2019-07-31 10:01:14', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (25, 'xiaoming2', NULL, NULL, '$2a$10$QqiPSJcL.cy2tBIprtBNweKBd5pOhYmrLqFuXkDtulz1dRTjBcdxi', '15727055421', NULL, '2019-07-31 10:03:42', '2019-07-31 10:03:42', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (26, 'xiaoming3', NULL, NULL, '$2a$10$.L6DUIn7U8sNXleftmFqqO7ZW77F9MCzoIi8GidPpKDX9LQhZ1LA6', '15727055422', NULL, '2019-07-31 10:05:14', '2019-07-31 10:05:14', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (27, 'xiaoming4', NULL, NULL, '$2a$10$VYyHLDRny5uoVyP5KzACRudq.cQYg5Ox71MwvgIXzSQ2BimylFTGa', '15727055423', NULL, '2019-07-31 10:07:53', '2019-07-31 10:07:53', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (28, 'xiaoming5', NULL, NULL, '$2a$10$VSHhbtMPyrV1ZBNiBHnjTOJIMdDKboxk9FqckyQQD2eRVv3uXQZLK', '15727055424', NULL, '2019-07-31 10:09:25', '2019-07-31 10:09:25', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (29, 'xiaoming6', NULL, NULL, '$2a$10$.bP7fB4qITjUtigDh0j7GuaLL3IxGPYPprZYIxvXTNx6INmjZY0Wm', '15727055425', NULL, '2019-07-31 10:13:39', '2019-07-31 10:13:39', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (30, 'xiaoming8', NULL, NULL, '$2a$10$Q0kHsDBADzfk0RoZOUlfJe0ved3i.tYrrZaGQVuBu55OSuG8DMxfu', '15727055426', NULL, '2019-07-31 10:37:17', '2019-07-31 10:37:17', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (31, 'xiaoming9', NULL, NULL, '$2a$10$i.oat7uoe/C7tOEaauE/neBvK.Q8vHT6YEpAIt0lLxDkvABpLUYCC', '15727055427', NULL, '2019-07-31 10:39:19', '2019-07-31 10:42:36', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (32, 'xiaohouzi1', NULL, NULL, '$2a$10$dvMDcXsCp6r2UjCi37GCp.hxrG42mjKgU2Awb28PvP347A7W5hbAy', '15727055430', NULL, '2019-07-31 10:46:43', '2019-07-31 10:46:53', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (33, 'xiaohouzi2', NULL, NULL, '$2a$10$orsABLqvuWewStxv9eUP7O9J7bb4EXSYw4pecafaTEmleR4l/EjEa', '15727055431', NULL, '2019-07-31 10:49:56', '2019-07-31 10:50:06', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (34, 'xiaohouzi3', NULL, NULL, '$2a$10$J8Pdn7308/KEMLtgS32Y1.PY9BaDxFWT2z73eOWEFWtA2rYPKOzN2', '15727055432', NULL, '2019-07-31 10:57:09', '2019-07-31 11:13:36', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (35, 'xiaohouzi4', NULL, NULL, '$2a$10$PCc4S.rUgREUq4AREyOYcu7ECng3dUtdCVwZQ80dtP1J83TlH9QI2', '15727055433', NULL, '2019-07-31 11:17:52', '2019-07-31 11:17:52', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (36, 'xiaohouzi5', NULL, NULL, '$2a$10$LRa5qgpmvIr27PLqExOCmeiSY36lzRpIOo41UBRXMqLXLq0o3OygO', '15727055434', NULL, '2019-07-31 11:20:16', '2019-07-31 11:20:34', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (37, 'xiaohou5', NULL, NULL, '$2a$10$qysreFhI3Dg6nEzFjBl2puyMUAgJGEwoxF5XeVJEkThZ5ZWltohQm', '15727055435', NULL, '2019-07-31 11:24:10', '2019-07-31 11:24:10', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (38, 'xiaohou6', NULL, NULL, '$2a$10$AQFF517K3r1ZEJeArIURAO6/4a//M.LvcFvquyvGogpUmljLAL3JK', '15727055436', NULL, '2019-07-31 11:30:27', '2019-07-31 11:30:27', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (39, 'xiaohou7', NULL, NULL, '$2a$10$bkScOVM5YzUO5QPGRjt.Q.rW9UIKu8Fq0bLmIPtyZCwhbklhCL3bO', '15727055437', NULL, '2019-07-31 11:31:46', '2019-07-31 11:31:46', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (40, 'xiaohou8', NULL, NULL, '$2a$10$RlEyIJNdQ68TdSIoT5LerOhrN5lbDDanXP2VDUvAUOG6bJK1QoQZ6', '15727055438', NULL, '2019-07-31 11:35:22', '2019-07-31 11:35:22', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (41, 'xiaohouzi9', NULL, NULL, '$2a$10$p6txbnLr2fvHENoihu60/.Dn2WOdZTED31BrxTj98eBdPBimRe65m', '15727055457', NULL, '2019-07-31 11:36:43', '2019-07-31 11:36:43', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (42, 'xiaoding1', NULL, NULL, '$2a$10$7YacMJo.vSZV8x8K2YPNm.FLy9Dhqo39c6gGSj9f8eufCkVxtDdvq', '15727055439', NULL, '2019-07-31 11:41:29', '2019-07-31 11:41:29', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (43, 'xiongchao333', NULL, NULL, '$2a$10$2Q32aGwh3syCuvbAlRH1D.Weehvmv7u6a.ayz0TVXYiQR5Lf7q1Oe', '13231312313', NULL, '2019-08-21 17:53:55', '2019-08-21 17:53:55', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (44, 'xiongchao12', NULL, NULL, '$2a$10$FmIj2L0JPqHyZSH85REIEuFpIjPVUujgK3KYwULLzcrvx5T/UpZ8C', '18111111111', NULL, '2019-08-21 17:57:16', '2019-08-21 17:57:16', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (45, 'xiongchao13', NULL, NULL, '$2a$10$gXnjlGOO/AYEYCbLwfoNze5tIUrpJlQdLVMJqKZwr8VfVzAjEzwpi', '18111111112', NULL, '2019-08-21 18:00:05', '2019-08-21 18:00:05', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (46, 'xiongchao122', NULL, NULL, '$2a$10$f5s5sI6.SHclEU1kZRogAOdyC7Mi0WjbPCwEXofqEsNXzDsDgcOd6', '18111111123', NULL, '2019-08-21 18:02:13', '2019-08-21 18:02:13', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `user` VALUES (47, 'xiongchao1223', NULL, NULL, '$2a$10$PsxQ4U4EO6GiBBkgYJmoz.FDpBmjtKJLzXM80CUuk89VEzfSQv1SS', '18111111234', NULL, '2019-08-21 18:04:20', '2019-08-21 18:04:20', NULL, 0, NULL, 'ROLE_USER', NULL, 2, NULL, NULL, NULL, NULL, 1, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
